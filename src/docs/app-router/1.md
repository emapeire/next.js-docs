# 1 - App Router

**Use the new App Router with Next.js' and React's latest features, including Layouts, Server Components, Suspense, and more.**

The Next.js App Router is a new paradigm for building applications using React’s latest features. If you’re already familiar with Next.js,

you’ll find that the App Router is a natural evolution of the existing file-system based router in the Pages Router.

For new applications, **we recommend using the App Router**. For existing applications, you can incrementally adopt the App Router.

It’s also possible to use both routers in the same application.

### Frequently Asked Questions

**How can I access the request object in a layout?**

You intentionally cannot access the raw request object. However, you can access headers and cookies through server-only functions.

You can also set cookies.

Layouts do not rerender. They can be cached and reused to avoid unnecessary computation when navigating between pages. By restricting layouts from accessing the raw request, Next.js can prevent the execution of potentially slow or expensive user code within the layout, which could negatively impact performance.

This design also enforces consistent and predictable behavior for layouts across different pages, which simplifies development and debugging.

Depending on the UI pattern you’re building, Parallel Routes allow you to render multiple pages in the same layout, and pages have access to the route segments as well as the URL search params.

**How can I access the URL on a page?**

By default, pages are Server Components. You can access the route segments through the params prop and the URL search params through the searchParams prop for a given page.

If you are using Client Components, you can use usePathname, useSelectedLayoutSegment, and useSelectedLayoutSegments for more complex routes.

Further, depending on the UI pattern you’re building, Parallel Routes allow you to render multiple pages in the same layout, and pages have access to the route segments as well as the URL search params.

**How can I redirect from a Server Component?**

You can use redirect to redirect from a page to a relative or absolute URL. redirect is a temporary (307) redirect, while permanentRedirect is a permanent (308) redirect. When these functions are used while streaming UI, they will insert a meta tag to emit the redirect on the client side.

**How can I handle authentication with the App Router?**

Here are some common authentication solutions that support the App Router:

- NextAuth.js
- Clerk
- Auth
- Stytch
- Kinde
- Or manually handling sessions or JWTs

**How can I set cookies?**

You can set cookies in Server Actions or Route Handlers using the cookies function.

Since HTTP does not allow setting cookies after streaming starts, you cannot set cookies from a page or layout directly. You can also set cookies from Middleware.

**How can I build multi-tenant apps?**

If you are looking to build a single Next.js application that serves multiple tenants, we have built an example showing our recommended architecture.

**How can I invalidate the App Router cache?**

There are multiple layers of caching in Next.js, and thus, multiple ways to invalidate different parts of the cache. Learn more about caching.

**Are there any comprehensive, open-source applications built on the App Router?**

Yes. You can view Next.js Commerce or the Platforms Starter Kit for two larger examples of using the App Router that are open-source.

### Learn More

- Routing Fundamentals
- Data Fetching, Caching, and Revalidating
- Forms and Mutations
- Caching
- Rendering Fundamentals
- Server Components
- Client Components

## 1.1 - Building Your Application

**Learn how to use Next.js features to build your application.**

_The content of this doc is shared between the app and pages router. You can use the_ `<PagesOnly>Content</PagesOnly>` _component to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component._

Next.js provides the building blocks to create flexible, full-stack web applications. The guides in **Building Your Application** explain how to use these features and how to customize your application’s behavior.

The sections and pages are organized sequentially, from basic to advanced, so you can follow them step-by-step when building your Next.js application. However, you can read them in any order or skip to the pages that apply to your use case.

If you’re new to Next.js, we recommend starting with the Routing, Rendering, Data Fetching and Styling sections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such as Optimizing and Configuring. Finally, once you’re ready, checkout the Deploying and Upgrading sections.

If you’re new to Next.js, we recommend starting with the Routing, Rendering, Data Fetching and Styling sections, as they introduce the fundamental Next.js and web concepts to help you get started. Then, you can dive deeper into the other sections such as Optimizing and Configuring. Finally, once you’re ready, checkout the Deploying and Upgrading sections.

## 1.1.1 - Routing Fundamentals

**Learn the fundamentals of routing for front-end applications.**

The skeleton of every application is routing. This page will introduce you to the **fundamental concepts** of routing for the web and how to handle routing in Next.js.

### Terminology

First, you will see these terms being used throughout the documentation. Here’s a quick reference:

- Tree: A convention for visualizing a hierarchical structure. For example, a component tree with parent and children components, a folder structure, etc.

- Subtree: Part of a tree, starting at a new root (first) and ending at the leaves (last).

- Root : The first node in a tree or subtree, such as a root layout.

- Leaf: Nodes in a subtree that have no children, such as the last segment in a URL path.

- URL Segment: Part of the URL path delimited by slashes.

- URL Path: Part of the URL that comes after the domain (composed of segments).

#### The appapp Router

In version 13, Next.js introduced a new **App Router** built on React Server Components, which supports shared layouts, nested routing,

loading states, error handling, and more.

The App Router works in a new directory named app. The app directory works alongside the pages directory to allow for incremental

adoption. This allows you to opt some routes of your application into the new behavior while keeping other routes in the pages

directory for previous behavior. If your application uses the pages directory, please also see the Pages Router documentation.

```
Good to know : The App Router takes priority over the Pages Router. Routes across directories should not resolve to the same
URL path and will cause a build-time error to prevent a conflict.
```

By default, components inside app are React Server Components. This is a performance optimization and allows you to easily adopt

them, and you can also use Client Components.

```
Recommendation: Check out the Server page if you’re new to Server Components.
```

##### Roles of Folders and Files

Next.js uses a file-system based router where:

```
Folders are used to define routes. A route is a single path of nested folders, following the file-system hierarchy from the root
folder down to a final leaf folder that includes a page.js file. See Defining Routes.
Files are used to create UI that is shown for a route segment. See special files.
```

##### Route Segments

Each folder in a route represents a **route segment**. Each route segment is mapped to a corresponding **segment** in a **URL path**.

##### Nested Routes

To create a nested route, you can nest folders inside each other. For example, you can add a new /dashboard/settings route by

nesting two new folders in the app directory.

The /dashboard/settings route is composed of three segments:

```
/ (Root segment)
dashboard (Segment)
settings (Leaf segment)
```

##### File Conventions

Next.js provides a set of special files to create UI with specific behavior in nested routes:

```
layout
Shared UI for a segment and its children
```

```
page Unique UI of a route and make routes publicly accessible
```

```
loading Loading UI for a segment and its children
```

```
not-found Not found UI for a segment and its children
```

```
error Error UI for a segment and its children
```

```
global-error Global Error UI
```

```
route Server-side API endpoint
```

```
template Specialized re-rendered Layout UI
```

```
default Fallback UI for Parallel Routes
```

```
Good to know : .js, .jsx, or .tsx file extensions can be used for special files.
```

##### Component Hierarchy

The React components defined in special files of a route segment are rendered in a specific hierarchy:

```
layout.js
template.js
error.js (React error boundary)
loading.js (React suspense boundary)
not-found.js (React error boundary)
page.js or nested layout.js
```

In a nested route, the components of a segment will be nested **inside** the components of its parent segment.

##### Colocation

In addition to special files, you have the option to colocate your own files (e.g. components, styles, tests, etc) inside folders in the app

directory.

This is because while folders define routes, only the contents returned by page.js or route.js are publicly addressable.

Learn more about Project Organization and Colocation.

##### Advanced Routing Patterns

The App Router also provides a set of conventions to help you implement more advanced routing patterns. These include:

```
Parallel Routes: Allow you to simultaneously show two or more pages in the same view that can be navigated independently. You
```

```
can use them for split views that have their own sub-navigation. E.g. Dashboards.
Intercepting Routes: Allow you to intercept a route and show it in the context of another route. You can use these when keeping the
context for the current page is important. E.g. Seeing all tasks while editing one task or expanding a photo in a feed.
```

These patterns allow you to build richer and more complex UIs, democratizing features that were historically complex for small teams

and individual developers to implement.

##### Next Steps

Now that you understand the fundamentals of routing in Next.js, follow the links below to create your first routes:

### 1.1.1.1 - Defining Routes

Documentation path: /02-app/01-building-your-application/01-routing/01-defining-routes

**Description:** Learn how to create your first route in Next.js.

```
Related:
Title: Related
Related Description: Learn more about creating pages and layouts.
Links:
```

```
app/building-your-application/routing/pages-and-layouts
```

```
We recommend reading the Routing Fundamentals page before continuing.
```

This page will guide you through how to define and organize routes in your Next.js application.

##### Creating Routes

Next.js uses a file-system based router where **folders** are used to define routes.

Each folder represents a **route** segment that maps to a **URL** segment. To create a nested route, you can nest folders inside each other.

A special page.js file is used to make route segments publicly accessible.

In this example, the /dashboard/analytics URL path is _not_ publicly accessible because it does not have a corresponding page.js

file. This folder could be used to store components, stylesheets, images, or other colocated files.

```
Good to know : .js, .jsx, or .tsx file extensions can be used for special files.
```

##### Creating UI

Special file conventions are used to create UI for each route segment. The most common are pages to show UI unique to a route, and

layouts to show UI that is shared across multiple routes.

For example, to create your first page, add a page.js file inside the app directory and export a React component:

```
app/page.tsx (tsx)
export default function Page() {
return <h1>Hello, Next.js!</h1>
}
```

```
app/page.js (jsx)
export default function Page() {
return <h1>Hello, Next.js!</h1>
}
```

### 1.1.1.2 - Pages and Layouts

Documentation path: /02-app/01-building-your-application/01-routing/02-pages-and-layouts

**Description:** Create your first page and shared layout with the App Router.

```
We recommend reading the Routing Fundamentals and Defining Routes pages before continuing.
```

The App Router inside Next.js 13 introduced new file conventions to easily create pages, shared layouts, and templates. This page will

guide you through how to use these special files in your Next.js application.

##### Pages

A page is UI that is **unique** to a route. You can define pages by exporting a component from a page.js file. Use nested folders to

define a route and a page.js file to make the route publicly accessible.

Create your first page by adding a page.js file inside the app directory:

```
app/page.tsx (tsx)
// `app/page.tsx` is the UI for the `/` URL
export default function Page() {
return <h1>Hello, Home page!</h1>
}
```

```
app/page.js (jsx)
// `app/page.js` is the UI for the `/` URL
export default function Page() {
return <h1>Hello, Home page!</h1>
}
```

```
app/dashboard/page.tsx (tsx)
// `app/dashboard/page.tsx` is the UI for the `/dashboard` URL
export default function Page() {
return <h1>Hello, Dashboard Page!</h1>
}
```

```
app/dashboard/page.js (jsx)
// `app/dashboard/page.js` is the UI for the `/dashboard` URL
export default function Page() {
return <h1>Hello, Dashboard Page!</h1>
}
```

```
Good to know :
```

```
A page is always the leaf of the route subtree.
.js, .jsx, or .tsx file extensions can be used for Pages.
A page.js file is required to make a route segment publicly accessible.
Pages are Server Components by default but can be set to a Client Component.
Pages can fetch data. View the Data Fetching section for more information.
```

##### Layouts

A layout is UI that is **shared** between multiple pages. On navigation, layouts preserve state, remain interactive, and do not re-render.

Layouts can also be nested.

You can define a layout by default exporting a React component from a layout.js file. The component should accept a children

prop that will be populated with a child layout (if it exists) or a child page during rendering.

```
app/dashboard/layout.tsx (tsx)
export default function DashboardLayout({
children, // will be a page or nested layout
}: {
children: React.ReactNode
}) {
return (
<section>
{/* Include shared UI here e.g. a header or sidebar */}
<nav></nav>
```

```
{children}
</section>
)
}
```

```
app/dashboard/layout.js (jsx)
export default function DashboardLayout({
children, // will be a page or nested layout
}) {
return (
<section>
{/* Include shared UI here e.g. a header or sidebar */}
<nav></nav>
```

```
{children}
</section>
)
}
```

```
Good to know :
```

```
The top-most layout is called the Root Layout. This required layout is shared across all pages in an application. Root
layouts must contain html and body tags.
Any route segment can optionally define its own Layout. These layouts will be shared across all pages in that segment.
Layouts in a route are nested by default. Each parent layout wraps child layouts below it using the React children prop.
You can use Route Groups to opt specific route segments in and out of shared layouts.
Layouts are Server Components by default but can be set to a Client Component.
Layouts can fetch data. View the Data Fetching section for more information.
Passing data between a parent layout and its children is not possible. However, you can fetch the same data in a route more
than once, and React will automatically dedupe the requests without affecting performance.
Layouts do not have access to the route segments below itself. To access all route segments, you can use
useSelectedLayoutSegment or useSelectedLayoutSegments in a Client Component.
.js, .jsx, or .tsx file extensions can be used for Layouts.
A layout.js and page.js file can be defined in the same folder. The layout will wrap the page.
```

**Root Layout (Required)**

The root layout is defined at the top level of the app directory and applies to all routes. This layout enables you to modify the initial

HTML returned from the server.

```
app/layout.tsx (tsx)
export default function RootLayout({
children,
}: {
children: React.ReactNode
}) {
return (
<html lang="en">
<body>{children}</body>
</html>
)
}
```

```
app/layout.js (jsx)
export default function RootLayout({ children }) {
return (
<html lang="en">
<body>{children}</body>
</html>
)
}
```

```
Good to know :
```

```
The app directory must include a root layout.
The root layout must define <html> and <body> tags since Next.js does not automatically create them.
You can use the built-in SEO support to manage <head> HTML elements, for example, the <title> element.
You can use route groups to create multiple root layouts. See an example here.
The root layout is a Server Component by default and can not be set to a Client Component.
```

```
Migrating from the pagespages directory: The root layout replaces the _app.js and _document.js files. View the migration
guide.
```

**Nesting Layouts**

Layouts defined inside a folder (e.g. app/dashboard/layout.js) apply to specific route segments (e.g. acme.com/dashboard) and

render when those segments are active. By default, layouts in the file hierarchy are **nested** , which means they wrap child layouts via

their children prop.

```
app/dashboard/layout.tsx (tsx)
export default function DashboardLayout({
children,
}: {
children: React.ReactNode
}) {
return <section>{children}</section>
}
```

```
app/dashboard/layout.js (jsx)
export default function DashboardLayout({ children }) {
return <section>{children}</section>
```

```
}
```

```
Good to know :
```

```
Only the root layout can contain <html> and <body> tags.
```

If you were to combine the two layouts above, the root layout (app/layout.js) would wrap the dashboard layout

(app/dashboard/layout.js), which would wrap route segments inside app/dashboard/\*.

The two layouts would be nested as such:

You can use Route Groups to opt specific route segments in and out of shared layouts.

##### Templates

Templates are similar to layouts in that they wrap each child layout or page. Unlike layouts that persist across routes and maintain

state, templates create a new instance for each of their children on navigation. This means that when a user navigates between routes

that share a template, a new instance of the component is mounted, DOM elements are recreated, state is **not** preserved, and effects

are re-synchronized.

There may be cases where you need those specific behaviors, and templates would be a more suitable option than layouts. For

example:

```
Features that rely on useEffect (e.g logging page views) and useState (e.g a per-page feedback form).
To change the default framework behavior. For example, Suspense Boundaries inside layouts only show the fallback the first time
the Layout is loaded and not when switching pages. For templates, the fallback is shown on each navigation.
```

A template can be defined by exporting a default React component from a template.js file. The component should accept a

children prop.

```
app/template.tsx (tsx)
export default function Template({ children }: { children: React.ReactNode }) {
return <div>{children}</div>
}
```

```
app/template.js (jsx)
export default function Template({ children }) {
return <div>{children}</div>
}
```

In terms of nesting, template.js is rendered between a layout and its children. Here’s a simplified output:

```
Output (jsx)
<Layout>
{/* Note that the template is given a unique key. */}
<Template key={routeParam}>{children}</Template>
</Layout>
```

#### Modifying <head><head>

In the app directory, you can modify the <head> HTML elements such as title and meta using the built-in SEO support.

Metadata can be defined by exporting a metadata object or generateMetadata function in a layout.js or page.js file.

```
app/page.tsx (tsx)
import { Metadata } from 'next'
```

```
export const metadata: Metadata = {
title: 'Next.js',
}
```

```
export default function Page() {
return '...'
}
```

```
app/page.js (jsx)
export const metadata = {
title: 'Next.js',
}
```

```
export default function Page() {
return '...'
}
```

```
Good to know : You should not manually add <head> tags such as <title> and <meta> to root layouts. Instead, you should
use the Metadata API which automatically handles advanced requirements such as streaming and de-duplicating <head>
elements.
```

Learn more about available metadata options in the API reference.

### 1.1.1.3 - Linking and Navigating

Documentation path: /02-app/01-building-your-application/01-routing/03-linking-and-navigating

**Description:** Learn how navigation works in Next.js, and how to use the Link Component and `useRouter` hook.

```
Related:
Title: Related
Related Description: No related description
Links:
```

```
app/building-your-application/caching
app/building-your-application/configuring/typescript
```

There are two ways to navigate between routes in Next.js:

```
Using the <Link> Component
Using the useRouter Hook
```

This page will go through how to use <Link>, useRouter(), and dive deeper into how navigation works.

#### <Link><Link> Component

<Link> is a built-in component that extends the HTML <a> tag to provide prefetching and client-side navigation between routes. It is

the primary way to navigate between routes in Next.js.

You can use it by importing it from next/link, and passing a href prop to the component:

```
app/page.tsx (tsx)
import Link from 'next/link'
```

```
export default function Page() {
return <Link href="/dashboard">Dashboard</Link>
}
```

```
app/page.js (jsx)
import Link from 'next/link'
```

```
export default function Page() {
return <Link href="/dashboard">Dashboard</Link>
}
```

There are other optional props you can pass to <Link>. See the API reference for more.

**Examples**

**Linking to Dynamic Segments**

When linking to dynamic segments, you can use template literals and interpolation to generate a list of links. For example, to generate

a list of blog posts:

```
app/blog/PostList.js (jsx)
import Link from 'next/link'
```

```
export default function PostList({ posts }) {
return (
<ul>
{posts.map((post) => (
<li key={post.id}>
<Link href={`/blog/${post.slug}`}>{post.title}</Link>
</li>
))}
</ul>
)
}
```

**Checking Active Links**

You can use usePathname() to determine if a link is active. For example, to add a class to the active link, you can check if the current

pathname matches the href of the link:

```
app/components/links.tsx (tsx)
'use client'
```

```
import { usePathname } from 'next/navigation'
import Link from 'next/link'
```

```
export function Links() {
const pathname = usePathname()
```

```
return (
<nav>
<ul>
<li>
<Link className={`link ${pathname === '/'? 'active' : ''}`} href="/">
Home
</Link>
</li>
<li>
<Link
className={`link ${pathname === '/about'? 'active' : ''}`}
href="/about"
>
About
</Link>
</li>
</ul>
</nav>
)
}
```

```
app/components/links.js (jsx)
'use client'
```

```
import { usePathname } from 'next/navigation'
import Link from 'next/link'
```

```
export function Links() {
const pathname = usePathname()
```

```
return (
<nav>
<ul>
<li>
<Link className={`link ${pathname === '/'? 'active' : ''}`} href="/">
Home
</Link>
</li>
<li>
<Link
className={`link ${pathname === '/about'? 'active' : ''}`}
href="/about"
>
About
</Link>
</li>
</ul>
</nav>
)
}
```

**Scrolling to an** idid

The default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and

forwards navigation.

If you’d like to scroll to a specific id on navigation, you can append your URL with a # hash link or just pass a hash link to the href

prop. This is possible since <Link> renders to an <a> element.

```
<Link href="/dashboard#settings">Settings</Link>
```

```
// Output
<a href="/dashboard#settings">Settings</a>
```

**Disabling scroll restoration**

The default behavior of the Next.js App Router is to scroll to the top of a new route or to maintain the scroll position for backwards and

forwards navigation. If you’d like to disable this behavior, you can pass scroll={false} to the <Link> component, or scroll:

false to router.push() or router.replace().

```
// next/link
<Link href="/dashboard" scroll={false}>
Dashboard
</Link>
```

```
// useRouter
import { useRouter } from 'next/navigation'
```

```
const router = useRouter()
```

```
router.push('/dashboard', { scroll: false })
```

#### useRouter()useRouter() Hook

The useRouter hook allows you to programmatically change routes.

This hook can only be used inside Client Components and is imported from next/navigation.

```
app/page.js (jsx)
'use client'
```

```
import { useRouter } from 'next/navigation'
```

```
export default function Page() {
const router = useRouter()
```

```
return (
<button type="button" onClick={() => router.push('/dashboard')}>
Dashboard
</button>
)
}
```

For a full list of useRouter methods, see the API reference.

```
Recommendation: Use the <Link> component to navigate between routes unless you have a specific requirement for using
useRouter.
```

##### How Routing and Navigation Works

The App Router uses a hybrid approach for routing and navigation. On the server, your application code is automatically code-split by

route segments. And on the client, Next.js prefetches and caches the route segments. This means, when a user navigates to a new

route, the browser doesn’t reload the page, and only the route segments that change re-render - improving the navigation experience

and performance.

**1. Prefetching**

Prefetching is a way to preload a route in the background before the user visits it.

There are two ways routes are prefetched in Next.js:

```
<Link><Link> component : Routes are automatically prefetched as they become visible in the user’s viewport. Prefetching happens when
the page first loads or when it comes into view through scrolling.
router.prefetch()router.prefetch(): The useRouter hook can be used to prefetch routes programmatically.
```

The<Link>’s prefetching behavior is different for static and dynamic routes:

```
Static Routes : prefetch defaults to true. The entire route is prefetched and cached.
Dynamic Routes : prefetch default to automatic. Only the shared layout down until the first loading.js file is prefetched and
cached for 30s. This reduces the cost of fetching an entire dynamic route, and it means you can show an instant loading state for
better visual feedback to users.
```

You can disable prefetching by setting the prefetch prop to false.

See the <Link> API reference for more information.

```
Good to know :
```

```
Prefetching is not enabled in development, only in production.
```

**2. Caching**

Next.js has an **in-memory client-side cache** called the Router Cache. As users navigate around the app, the React Server Component

Payload of prefetched route segments and visited routes are stored in the cache.

This means on navigation, the cache is reused as much as possible, instead of making a new request to the server - improving

performance by reducing the number of requests and data transferred.

Learn more about how the Router Cache works and how to configure it.

**3. Partial Rendering**

Partial rendering means only the route segments that change on navigation re-render on the client, and any shared segments are

preserved.

For example, when navigating between two sibling routes, /dashboard/settings and /dashboard/analytics, the settings and

analytics pages will be rendered, and the shared dashboard layout will be preserved.

Without partial rendering, each navigation would cause the full page to re-render on the server. Rendering only the segment that

changes reduces the amount of data transferred and execution time, leading to improved performance.

**4. Soft Navigation**

By default, the browser performs a hard navigation between pages. This means the browser reloads the page and resets React state

such as useState hooks in your app and browser state such as the user’s scroll position or focused element. However, in Next.js, the

App Router uses soft navigation. This means React only renders the segments that have changed while preserving React and browser

state, and there is no full page reload.

**5. Back and Forward Navigation**

By default, Next.js will maintain the scroll position for backwards and forwards navigation, and re-use route segments in the Router

Cache.

### 1.1.1.4 - Route Groups

Documentation path: /02-app/01-building-your-application/01-routing/04-route-groups

**Description:** Route Groups can be used to partition your Next.js application into different sections.

In the app directory, nested folders are normally mapped to URL paths. However, you can mark a folder as a **Route Group** to prevent

the folder from being included in the route’s URL path.

This allows you to organize your route segments and project files into logical groups without affecting the URL path structure.

Route groups are useful for:

```
Organizing routes into groups e.g. by site section, intent, or team.
Enabling nested layouts in the same route segment level:
Creating multiple nested layouts in the same segment, including multiple root layouts
Adding a layout to a subset of routes in a common segment
```

##### Convention

A route group can be created by wrapping a folder’s name in parenthesis: (folderName)

##### Examples

**Organize routes without affecting the URL path**

To organize routes without affecting the URL, create a group to keep related routes together. The folders in parenthesis will be omitted

from the URL (e.g. (marketing) or (shop)).

Even though routes inside (marketing) and (shop) share the same URL hierarchy, you can create a different layout for each group by

adding a layout.js file inside their folders.

**Opting specific segments into a layout**

To opt specific routes into a layout, create a new route group (e.g. (shop)) and move the routes that share the same layout into the

group (e.g. account and cart). The routes outside of the group will not share the layout (e.g. checkout).

**Creating multiple root layouts**

To create multiple root layouts, remove the top-level layout.js file, and add a layout.js file inside each route groups. This is useful

for partitioning an application into sections that have a completely different UI or experience. The <html> and <body> tags need to be

added to each root layout.

In the example above, both (marketing) and (shop) have their own root layout.

```
Good to know :
```

```
The naming of route groups has no special significance other than for organization. They do not affect the URL path.
Routes that include a route group should not resolve to the same URL path as other routes. For example, since route
groups don’t affect URL structure, (marketing)/about/page.js and (shop)/about/page.js would both resolve to
/about and cause an error.
If you use multiple root layouts without a top-level layout.js file, your home page.js file should be defined in one of the
route groups, For example: app/(marketing)/page.js.
Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation). For example,
navigating from /cart that uses app/(shop)/layout.js to /blog that uses app/(marketing)/layout.js will cause a
full page load. This only applies to multiple root layouts.
```

### 1.1.1.5 - Dynamic Routes

Documentation path: /02-app/01-building-your-application/01-routing/05-dynamic-routes

**Description:** Dynamic Routes can be used to programmatically generate route segments from dynamic data.

```
Related:
Title: Next Steps
Related Description: For more information on what to do next, we recommend the following sections
Links:
```

```
app/building-your-application/routing/linking-and-navigating
app/api-reference/functions/generate-static-params
```

When you don’t know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic

Segments that are filled in at request time or prerendered at build time.

##### Convention

A Dynamic Segment can be created by wrapping a folder’s name in square brackets: [folderName]. For example, [id] or [slug].

Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions.

##### Example

For example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog

posts.

```
app/blog/[slug]/page.tsx (tsx)
export default function Page({ params }: { params: { slug: string } }) {
return <div>My Post: {params.slug}</div>
}
```

```
app/blog/[slug]/page.js (jsx)
export default function Page({ params }) {
return <div>My Post: {params.slug}</div>
}
```

```
Route Example URL paramsparams
```

```
app/blog/[slug]/page.js /blog/a { slug: 'a' }
```

```
app/blog/[slug]/page.js /blog/b { slug: 'b' }
```

```
app/blog/[slug]/page.js /blog/c { slug: 'c' }
```

See the generateStaticParams() page to learn how to generate the params for the segment.

```
Good to know : Dynamic Segments are equivalent to Dynamic Routes in the pages directory.
```

##### Generating Static Params

The generateStaticParams function can be used in combination with dynamic route segments to **statically generate** routes at build

time instead of on-demand at request time.

```
app/blog/[slug]/page.tsx (tsx)
export async function generateStaticParams() {
const posts = await fetch('https://.../posts').then((res) => res.json())
```

```
return posts.map((post) => ({
slug: post.slug,
}))
}
```

```
app/blog/[slug]/page.js (jsx)
export async function generateStaticParams() {
```

```
const posts = await fetch('https://.../posts').then((res) => res.json())
```

```
return posts.map((post) => ({
slug: post.slug,
}))
}
```

The primary benefit of the generateStaticParams function is its smart retrieval of data. If content is fetched within the

generateStaticParams function using a fetch request, the requests are automatically memoized. This means a fetch request with

the same arguments across multiple generateStaticParams, Layouts, and Pages will only be made once, which decreases build

times.

Use the migration guide if you are migrating from the pages directory.

See generateStaticParams server function documentation for more information and advanced use cases.

##### Catch-all Segments

Dynamic Segments can be extended to **catch-all** subsequent segments by adding an ellipsis inside the brackets [...folderName].

For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops,

/shop/clothes/tops/t-shirts, and so on.

```
Route Example URL paramsparams
```

```
app/shop/[...slug]/page.js /shop/a { slug: ['a'] }
```

```
app/shop/[...slug]/page.js /shop/a/b { slug: ['a', 'b'] }
```

```
app/shop/[...slug]/page.js /shop/a/b/c { slug: ['a', 'b', 'c'] }
```

##### Optional Catch-all Segments

Catch-all Segments can be made **optional** by including the parameter in double square brackets: [[...folderName]].

For example, app/shop/[[...slug]]/page.js will **also** match /shop, in addition to /shop/clothes, /shop/clothes/tops,

/shop/clothes/tops/t-shirts.

The difference between **catch-all** and **optional catch-all** segments is that with optional, the route without the parameter is also

matched (/shop in the example above).

```
Route Example URL paramsparams
```

```
app/shop/[[...slug]]/page.js /shop {}
```

```
app/shop/[[...slug]]/page.js /shop/a { slug: ['a'] }
```

```
app/shop/[[...slug]]/page.js /shop/a/b { slug: ['a', 'b'] }
```

```
app/shop/[[...slug]]/page.js /shop/a/b/c { slug: ['a', 'b', 'c'] }
```

##### TypeScript

When using TypeScript, you can add types for params depending on your configured route segment.

```
app/blog/[slug]/page.tsx (tsx)
export default function Page({ params }: { params: { slug: string } }) {
return <h1>My Page</h1>
}
```

```
app/blog/[slug]/page.js (jsx)
export default function Page({ params }) {
return <h1>My Page</h1>
}
```

```
Route paramsparams Type Definition
```

```
app/blog/[slug]/page.js { slug: string }
```

app/shop/[...slug]/page.js { slug: string[] }

app/[categoryId]/[itemId]/page.js { categoryId: string, itemId: string }

**Route** paramsparams **Type Definition**

```
Good to know : This may be done automatically by the TypeScript plugin in the future.
```

### 1.1.1.6 - Loading UI and Streaming

Documentation path: /02-app/01-building-your-application/01-routing/06-loading-ui-and-streaming

**Description:** Built on top of Suspense, Loading UI allows you to create a fallback for specific route segments, and automatically stream

content as it becomes ready.

The special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an

instant loading state from the server while the content of a route segment loads. The new content is automatically swapped in once

rendering is complete.

##### Instant Loading States

An instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as

skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand

the app is responding and provides a better user experience.

Create a loading state by adding a loading.js file inside a folder.

```
app/dashboard/loading.tsx (tsx)
export default function Loading() {
// You can add any UI inside Loading, including a Skeleton.
return <LoadingSkeleton />
}
```

```
app/dashboard/loading.js (jsx)
export default function Loading() {
// You can add any UI inside Loading, including a Skeleton.
return <LoadingSkeleton />
}
```

In the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in

a <Suspense> boundary.

```
Good to know :
```

```
Navigation is immediate, even with server-centric routing.
Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before
navigating to another route.
Shared layouts remain interactive while new route segments load.
```

```
Recommendation: Use the loading.js convention for route segments (layouts and pages) as Next.js optimizes this
functionality.
```

##### Streaming with Suspense

In addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports

streaming with Suspense for both Node.js and Edge runtimes.

**What is Streaming?**

To learn how Streaming works in React and Next.js, it’s helpful to understand **Server-Side Rendering (SSR)** and its limitations.

With SSR, there’s a series of steps that need to be completed before a user can see and interact with a page:

```
1. First, all data for a given page is fetched on the server.
2. The server then renders the HTML for the page.
3. The HTML, CSS, and JavaScript for the page are sent to the client.
4. A non-interactive user interface is shown using the generated HTML, and CSS.
5. Finally, React hydrates the user interface to make it interactive.
```

These steps are sequential and blocking, meaning the server can only render the HTML for a page once all the data has been fetched.

And, on the client, React can only hydrate the UI once the code for all components in the page has been downloaded.

SSR with React and Next.js helps improve the perceived loading performance by showing a non-interactive page to the user as soon as

possible.

However, it can still be slow as all data fetching on server needs to be completed before the page can be shown to the user.

**Streaming** allows you to break down the page’s HTML into smaller chunks and progressively send those chunks from the server to the

client.

This enables parts of the page to be displayed sooner, without waiting for all the data to load before any UI can be rendered.

Streaming works well with React’s component model because each component can be considered a chunk. Components that have

higher priority (e.g. product information) or that don’t rely on data can be sent first (e.g. layout), and React can start hydration earlier.

Components that have lower priority (e.g. reviews, related products) can be sent in the same server request after their data has been

fetched.

Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can

reduce the Time To First Byte (TTFB) and First Contentful Paint (FCP). It also helps improve Time to Interactive (TTI), especially on slower

devices.

**Example**

<Suspense> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton,

spinner) while it’s happening, and then swapping in your component once the action completes.

```
app/dashboard/page.tsx (tsx)
import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'
```

```
export default function Posts() {
return (
<section>
<Suspense fallback={<p>Loading feed...</p>}>
<PostFeed />
</Suspense>
<Suspense fallback={<p>Loading weather...</p>}>
```

```
<Weather />
</Suspense>
</section>
)
}
```

```
app/dashboard/page.js (jsx)
import { Suspense } from 'react'
import { PostFeed, Weather } from './Components'
```

```
export default function Posts() {
return (
<section>
<Suspense fallback={<p>Loading feed...</p>}>
<PostFeed />
</Suspense>
<Suspense fallback={<p>Loading weather...</p>}>
<Weather />
</Suspense>
</section>
)
}
```

By using Suspense, you get the benefits of:

```
1. Streaming Server Rendering - Progressively rendering HTML from the server to the client.
2. Selective Hydration - React prioritizes what components to make interactive first based on user interaction.
```

For more Suspense examples and use cases, please see the React Documentation.

**SEO**

```
Next.js will wait for data fetching inside generateMetadata to complete before streaming UI to the client. This guarantees the first
part of a streamed response includes <head> tags.
Since streaming is server-rendered, it does not impact SEO. You can use the Mobile Friendly Test tool from Google to see how your
page appears to Google’s web crawlers and view the serialized HTML (source).
```

**Status Codes**

When streaming, a 200 status code will be returned to signal that the request was successful.

The server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or

notFound. Since the response headers have already been sent to the client, the status code of the response cannot be updated. This

does not affect SEO.

### 1.1.1.7 - Error Handling

Documentation path: /02-app/01-building-your-application/01-routing/07-error-handling

**Description:** Handle runtime errors by automatically wrapping route segments and their nested children in a React Error Boundary.

```
Related:
Title: Related
Related Description: No related description
Links:
```

```
app/api-reference/file-conventions/error
```

The error.js file convention allows you to gracefully handle unexpected runtime errors in nested routes.

```
Automatically wrap a route segment and its nested children in a React Error Boundary.
Create error UI tailored to specific segments using the file-system hierarchy to adjust granularity.
Isolate errors to affected segments while keeping the rest of the application functional.
Add functionality to attempt to recover from an error without a full page reload.
```

Create error UI by adding an error.js file inside a route segment and exporting a React component:

```
app/dashboard/error.tsx (tsx)
'use client' // Error components must be Client Components
```

```
import { useEffect } from 'react'
```

```
export default function Error({
error,
reset,
}: {
error: Error & { digest?: string }
reset: () => void
}) {
useEffect(() => {
// Log the error to an error reporting service
console.error(error)
}, [error])
```

```
return (
<div>
<h2>Something went wrong!</h2>
<button
onClick={
// Attempt to recover by trying to re-render the segment
() => reset()
}
>
Try again
</button>
</div>
)
}
```

```
app/dashboard/error.js (jsx)
'use client' // Error components must be Client Components
```

```
import { useEffect } from 'react'
```

```
export default function Error({ error, reset }) {
useEffect(() => {
// Log the error to an error reporting service
console.error(error)
}, [error])
```

```
return (
<div>
<h2>Something went wrong!</h2>
<button
onClick={
// Attempt to recover by trying to re-render the segment
() => reset()
}
>
Try again
</button>
</div>
)
}
```

###### How error.jserror.js Works

```
error.js automatically creates a React Error Boundary that wraps a nested child segment or page.js component.
The React component exported from the error.js file is used as the fallback component.
If an error is thrown within the error boundary, the error is contained , and the fallback component is rendered.
When the fallback error component is active, layouts above the error boundary maintain their state and remain interactive, and
the error component can display functionality to recover from the error.
```

**Recovering From Errors**

The cause of an error can sometimes be temporary. In these cases, simply trying again might resolve the issue.

An error component can use the reset() function to prompt the user to attempt to recover from the error. When executed, the

function will try to re-render the Error boundary’s contents. If successful, the fallback error component is replaced with the result of the

re-render.

```
app/dashboard/error.tsx (tsx)
'use client'
```

```
export default function Error({
error,
reset,
}: {
error: Error & { digest?: string }
reset: () => void
}) {
return (
<div>
<h2>Something went wrong!</h2>
<button onClick={() => reset()}>Try again</button>
</div>
)
}
```

```
app/dashboard/error.js (jsx)
'use client'
```

```
export default function Error({ error, reset }) {
return (
<div>
<h2>Something went wrong!</h2>
<button onClick={() => reset()}>Try again</button>
</div>
)
}
```

**Nested Routes**

React components created through special files are rendered in a specific nested hierarchy.

For example, a nested route with two segments that both include layout.js and error.js files are rendered in the following

_simplified_ component hierarchy:

The nested component hierarchy has implications for the behavior of error.js files across a nested route:

```
Errors bubble up to the nearest parent error boundary. This means an error.js file will handle errors for all its nested child
segments. More or less granular error UI can be achieved by placing error.js files at different levels in the nested folders of a
route.
An error.js boundary will not handle errors thrown in a layout.js component in the same segment because the error
boundary is nested inside that layout’s component.
```

**Handling Errors in Layouts**

error.js boundaries do **not** catch errors thrown in layout.js or template.js components of the **same segment**. This intentional

hierarchy keeps important UI that is shared between sibling routes (such as navigation) visible and functional when an error occurs.

To handle errors within a specific layout or template, place an error.js file in the layout’s parent segment.

To handle errors within the root layout or template, use a variation of error.js called global-error.js.

**Handling Errors in Root Layouts**

The root app/error.js boundary does **not** catch errors thrown in the root app/layout.js or app/template.js component.

To specifically handle errors in these root components, use a variation of error.js called app/global-error.js located in the root

app directory.

Unlike the root error.js, the global-error.js error boundary wraps the **entire** application, and its fallback component replaces

the root layout when active. Because of this, it is important to note that global-error.js **must** define its own <html> and <body>

tags.

global-error.js is the least granular error UI and can be considered “catch-all” error handling for the whole application. It is unlikely

to be triggered often as root components are typically less dynamic, and other error.js boundaries will catch most errors.

Even if a global-error.js is defined, it is still recommended to define a root error.js whose fallback component will be rendered

**within** the root layout, which includes globally shared UI and branding.

```
app/global-error.tsx (tsx)
'use client'
```

```
export default function GlobalError({
error,
reset,
}: {
error: Error & { digest?: string }
reset: () => void
}) {
return (
<html>
<body>
<h2>Something went wrong!</h2>
<button onClick={() => reset()}>Try again</button>
</body>
</html>
)
}
```

```
app/global-error.js (jsx)
'use client'
```

```
export default function GlobalError({ error, reset }) {
return (
<html>
<body>
<h2>Something went wrong!</h2>
<button onClick={() => reset()}>Try again</button>
</body>
</html>
)
}
```

**Handling Server Errors**

If an error is thrown inside a Server Component, Next.js will forward an Error object (stripped of sensitive error information in

production) to the nearest error.js file as the error prop.

**Securing Sensitive Error Information**

During production, the Error object forwarded to the client only includes a generic message and digest property.

This is a security precaution to avoid leaking potentially sensitive details included in the error to the client.

The message property contains a generic message about the error and the digest property contains an automatically generated hash

of the error that can be used to match the corresponding error in server-side logs.

During development, the Error object forwarded to the client will be serialized and include the message of the original error for easier

debugging.

### 1.1.1.8 - Parallel Routes

Documentation path: /02-app/01-building-your-application/01-routing/08-parallel-routes

**Description:** Simultaneously render one or more pages in the same view that can be navigated independently. A pattern for highly

dynamic applications.

Parallel Routing allows you to simultaneously or conditionally render one or more pages in the same layout. For highly dynamic

sections of an app, such as dashboards and feeds on social sites, Parallel Routing can be used to implement complex routing patterns.

For example, you can simultaneously render the team and analytics pages.

Parallel Routing allows you to define independent error and loading states for each route as they’re being streamed in independently.

Parallel Routing also allows you to conditionally render a slot based on certain conditions, such as authentication state. This enables

fully separated code on the same URL.

##### Convention

Parallel routes are created using named **slots**. Slots are defined with the @folder convention, and are passed to the same-level layout

as props.

```
Slots are not route segments and do not affect the URL structure. The file path /@team/members would be accessible at
/members.
```

For example, the following file structure defines two explicit slots: @analytics and @team.

The folder structure above means that the component in app/layout.js now accepts the @analytics and @team slots props, and

can render them in parallel alongside the children prop:

```
app/layout.tsx (tsx)
export default function Layout(props: {
children: React.ReactNode
analytics: React.ReactNode
team: React.ReactNode
}) {
return (
<>
{props.children}
{props.team}
{props.analytics}
</>
)
}
```

```
app/layout.js (jsx)
export default function Layout(props) {
return (
<>
{props.children}
{props.team}
{props.analytics}
</>
)
}
```

```
Good to know : The children prop is an implicit slot that does not need to be mapped to a folder. This means app/page.js is
equivalent to app/@children/page.js.
```

##### Unmatched Routes

By default, the content rendered within a slot will match the current URL.

In the case of an unmatched slot, the content that Next.js renders differs based on the routing technique and folder structure.

###### default.jsdefault.js

You can define a default.js file to render as a fallback when Next.js cannot recover a slot’s active state based on the current URL.

Consider the following folder structure. The @team slot has a settings directory, but @analytics does not.

**Navigation**

On navigation, Next.js will render the slot’s previously active state, even if it doesn’t match the current URL.

**Reload**

On reload, Next.js will first try to render the unmatched slot’s default.js file. If that’s not available, a 404 gets rendered.

```
The 404 for unmatched routes helps ensure that you don’t accidentally render a route that shouldn’t be parallel rendered.
```

#### useSelectedLayoutSegment(s)useSelectedLayoutSegment(s)

Both useSelectedLayoutSegment and useSelectedLayoutSegments accept a parallelRoutesKey, which allows you to read the

active route segment within that slot.

```
app/layout.tsx (tsx)
'use client'
```

```
import { useSelectedLayoutSegment } from 'next/navigation'
```

```
export default function Layout(props: {
//...
auth: React.ReactNode
}) {
const loginSegments = useSelectedLayoutSegment('auth')
// ...
}
```

```
app/layout.js (jsx)
'use client'
```

```
import { useSelectedLayoutSegment } from 'next/navigation'
```

```
export default function Layout(props) {
const loginSegments = useSelectedLayoutSegment('auth')
// ...
}
```

When a user navigates to @auth/login, or /login in the URL bar, loginSegments will be equal to the string "login".

##### Examples

**Modals**

Parallel Routing can be used to render modals.

The @auth slot renders a <Modal> component that can be shown by navigating to a matching route, for example /login.

```
app/layout.tsx (tsx)
export default async function Layout(props: {
// ...
auth: React.ReactNode
}) {
return (
<>
{/* ... */}
{props.auth}
</>
)
}
```

```
app/layout.js (jsx)
export default async function Layout(props) {
return (
<>
{/* ... */}
{props.auth}
</>
)
}
```

```
app/@auth/login/page.tsx (tsx)
import { Modal } from 'components/modal'
```

```
export default function Login() {
return (
<Modal>
<h1>Login</h1>
{/* ... */}
</Modal>
)
}
```

```
app/@auth/login/page.js (jsx)
import { Modal } from 'components/modal'
```

```
export default function Login() {
return (
<Modal>
<h1>Login</h1>
{/* ... */}
</Modal>
)
}
```

To ensure that the contents of the modal don’t get rendered when it’s not active, you can create a default.js file that returns null.

```
app/@auth/default.tsx (tsx)
export default function Default() {
return null
}
```

```
app/@auth/default.js (jsx)
export default function Default() {
return null
}
```

**Dismissing a modal**

If a modal was initiated through client navigation, e.g. by using <Link href="/login">, you can dismiss the modal by calling

router.back() or by using a Link component.

```tsx filename=”app/@auth/login/page.tsx” highlight=”5” switcher ‘use client’ import { useRouter } from ‘next/navigation’ import { Modal

} from ‘components/modal’

export default function Login() { const router = useRouter() return ( router.back()}>Close modal

### Login

... ) }

```

```jsx filename="app/@auth/login/page.js" highlight="5" switcher
'use client'
import { useRouter } from 'next/navigation'
import { Modal } from 'components/modal'
```

```
export default function Login() {
const router = useRouter()
return (
<Modal>
<span onClick={() => router.back()}>Close modal</span>
<h1>Login</h1>
...
</Modal>
)
}
```

```
More information on modals is covered in the Intercepting Routes section.
```

If you want to navigate elsewhere and dismiss a modal, you can also use a catch-all route.

```
app/@auth/[...catchAll]/page.tsx (tsx)
export default function CatchAll() {
return null
}
```

```
app/@auth/[...catchAll]/page.js (jsx)
export default function CatchAll() {
return null
}
```

```
Catch-all routes take precedence over default.js.
```

**Conditional Routes**

Parallel Routes can be used to implement conditional routing. For example, you can render a @dashboard or @login route depending

on the authentication state.

```
app/layout.tsx (tsx)
import { getUser } from '@/lib/auth'
```

```
export default function Layout({
dashboard,
login,
}: {
dashboard: React.ReactNode
login: React.ReactNode
}) {
const isLoggedIn = getUser()
return isLoggedIn? dashboard : login
}
```

```
app/layout.js (jsx)
import { getUser } from '@/lib/auth'
```

```
export default function Layout({ dashboard, login }) {
const isLoggedIn = getUser()
return isLoggedIn? dashboard : login
}
```

### 1.1.1.9 - Intercepting Routes

Documentation path: /02-app/01-building-your-application/01-routing/09-intercepting-routes

**Description:** Use intercepting routes to load a new route within the current layout while masking the browser URL, useful for advanced

routing patterns such as modals.

```
Related:
Title: Next Steps
Related Description: Learn how to use modals with Intercepted and Parallel Routes.
Links:
```

```
app/building-your-application/routing/parallel-routes
```

Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm

can be useful when you want to display the content of a route without the user switching to a different context.

For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed. In this case, Next.js

intercepts the /photo/123 route, masks the URL, and overlays it over /feed.

However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render

instead of the modal. No route interception should occur.

##### Convention

Intercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for segments.

You can use:

```
(.) to match segments on the same level
(..) to match segments one level above
(..)(..) to match segments two levels above
```

```
(...) to match segments from the root app directory
```

For example, you can intercept the photo segment from within the feed segment by creating a (..)photo directory.

```
Note that the (..) convention is based on route segments , not the file-system.
```

##### Examples

**Modals**

Intercepting Routes can be used together with Parallel Routes to create modals.

Using this pattern to create modals overcomes some common challenges when working with modals, by allowing you to:

```
Make the modal content shareable through a URL
Preserve context when the page is refreshed, instead of closing the modal
Close the modal on backwards navigation rather than going to the previous route
Reopen the modal on forwards navigation
```

```
In the above example, the path to the photo segment can use the (..) matcher since @modal is a slot and not a segment. This
means that the photo route is only one segment level higher, despite being two file-system levels higher.
```

Other examples could include opening a login modal in a top navbar while also having a dedicated /login page, or opening a shopping

cart in a side modal.

View an example of modals with Intercepted and Parallel Routes.

### 1.1.1.10 - Route Handlers

Documentation path: /02-app/01-building-your-application/01-routing/10-route-handlers

**Description:** Create custom request handlers for a given route using the Web's Request and Response APIs.

```
Related:
Title: API Reference
Related Description: Learn more about the route.js file.
Links:
```

```
app/api-reference/file-conventions/route
```

Route Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs.

```
Good to know : Route Handlers are only available inside the app directory. They are the equivalent of API Routes inside the
pages directory meaning you do not need to use API Routes and Route Handlers together.
```

##### Convention

Route Handlers are defined in a route.js|ts file inside the app directory:

```
app/api/route.ts (ts)
export const dynamic = 'force-dynamic' // defaults to auto
export async function GET(request: Request) {}
```

```
app/api/route.js (js)
export const dynamic = 'force-dynamic' // defaults to auto
export async function GET(request) {}
```

Route Handlers can be nested inside the app directory, similar to page.js and layout.js. But there **cannot** be a route.js file at the

same route segment level as page.js.

**Supported HTTP Methods**

The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. If an unsupported method is called,

Next.js will return a 405 Method Not Allowed response.

###### Extended NextRequestNextRequest and NextResponseNextResponse APIs

In addition to supporting native Request and Response. Next.js extends them with NextRequest and NextResponse to provide

convenient helpers for advanced use cases.

##### Behavior

**Caching**

Route Handlers are cached by default when using the GET method with the Response object.

```
app/items/route.ts (ts)
export async function GET() {
const res = await fetch('https://data.mongodb-api.com/...', {
headers: {
```

```
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY,
},
})
const data = await res.json()
```

```
return Response.json({ data })
}
```

```
app/items/route.js (js)
export async function GET() {
const res = await fetch('https://data.mongodb-api.com/...', {
headers: {
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY,
},
})
const data = await res.json()
```

```
return Response.json({ data })
}
```

```
TypeScript Warning: Response.json() is only valid from TypeScript 5.2. If you use a lower TypeScript version, you can use
NextResponse.json() for typed responses instead.
```

**Opting out of caching**

You can opt out of caching by:

```
Using the Request object with the GET method.
Using any of the other HTTP methods.
Using Dynamic Functions like cookies and headers.
The Segment Config Options manually specifies dynamic mode.
```

For example:

```
app/products/api/route.ts (ts)
export async function GET(request: Request) {
const { searchParams } = new URL(request.url)
const id = searchParams.get('id')
const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {
headers: {
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY!,
},
})
const product = await res.json()
```

```
return Response.json({ product })
}
```

```
app/products/api/route.js (js)
export async function GET(request) {
const { searchParams } = new URL(request.url)
const id = searchParams.get('id')
const res = await fetch(`https://data.mongodb-api.com/product/${id}`, {
headers: {
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY,
},
})
const product = await res.json()
```

```
return Response.json({ product })
}
```

Similarly, the POST method will cause the Route Handler to be evaluated dynamically.

```
app/items/route.ts (ts)
export async function POST() {
const res = await fetch('https://data.mongodb-api.com/...', {
method: 'POST',
headers: {
```

```
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY!,
},
body: JSON.stringify({ time: new Date().toISOString() }),
})
```

```
const data = await res.json()
```

```
return Response.json(data)
}
```

```
app/items/route.js (js)
export async function POST() {
const res = await fetch('https://data.mongodb-api.com/...', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
'API-Key': process.env.DATA_API_KEY,
},
body: JSON.stringify({ time: new Date().toISOString() }),
})
```

```
const data = await res.json()
```

```
return Response.json(data)
}
```

```
Good to know : Like API Routes, Route Handlers can be used for cases like handling form submissions. A new abstraction for
handling forms and mutations that integrates deeply with React is being worked on.
```

**Route Resolution**

You can consider a route the lowest level routing primitive.

```
They do not participate in layouts or client-side navigations like page.
There cannot be a route.js file at the same route as page.js.
```

```
Page Route Result
```

```
app/page.js app/route.js Conflict
```

```
app/page.js app/api/route.js Valid
```

```
app/[user]/page.js app/api/route.js Valid
```

Each route.js or page.js file takes over all HTTP verbs for that route.

```
app/page.js (jsx)
export default function Page() {
return <h1>Hello, Next.js!</h1>
}
```

```
//  Conflict
// `app/route.js`
export async function POST(request) {}
```

##### Examples

The following examples show how to combine Route Handlers with other Next.js APIs and features.

**Revalidating Cached Data**

You can revalidate cached data using the next.revalidate option:

```
app/items/route.ts (ts)
export async function GET() {
const res = await fetch('https://data.mongodb-api.com/...', {
next: { revalidate: 60 }, // Revalidate every 60 seconds
})
const data = await res.json()
```

```
return Response.json(data)
}
```

```
app/items/route.js (js)
export async function GET() {
const res = await fetch('https://data.mongodb-api.com/...', {
next: { revalidate: 60 }, // Revalidate every 60 seconds
})
const data = await res.json()
```

```
return Response.json(data)
}
```

Alternatively, you can use the revalidate segment config option:

```
export const revalidate = 60
```

**Dynamic Functions**

Route Handlers can be used with dynamic functions from Next.js, like cookies and headers.

**Cookies**

You can read or set cookies with cookies from next/headers. This server function can be called directly in a Route Handler, or

nested inside of another function.

Alternatively, you can return a new Response using the Set-Cookie header.

```
app/api/route.ts (ts)
import { cookies } from 'next/headers'
```

```
export async function GET(request: Request) {
const cookieStore = cookies()
const token = cookieStore.get('token')
```

```
return new Response('Hello, Next.js!', {
status: 200 ,
headers: { 'Set-Cookie': `token=${token.value}` },
})
}
```

```
app/api/route.js (js)
import { cookies } from 'next/headers'
```

```
export async function GET(request) {
const cookieStore = cookies()
const token = cookieStore.get('token')
```

```
return new Response('Hello, Next.js!', {
status: 200 ,
headers: { 'Set-Cookie': `token=${token}` },
})
}
```

You can also use the underlying Web APIs to read cookies from the request (NextRequest):

```
app/api/route.ts (ts)
import { type NextRequest } from 'next/server'
```

```
export async function GET(request: NextRequest) {
const token = request.cookies.get('token')
}
```

```
app/api/route.js (js)
export async function GET(request) {
const token = request.cookies.get('token')
}
```

**Headers**

You can read headers with headers from next/headers. This server function can be called directly in a Route Handler, or nested

inside of another function.

This headers instance is read-only. To set headers, you need to return a new Response with new headers.

```
app/api/route.ts (ts)
import { headers } from 'next/headers'
```

```
export async function GET(request: Request) {
const headersList = headers()
const referer = headersList.get('referer')
```

```
return new Response('Hello, Next.js!', {
status: 200 ,
headers: { referer: referer },
})
}
```

```
app/api/route.js (js)
import { headers } from 'next/headers'
```

```
export async function GET(request) {
const headersList = headers()
const referer = headersList.get('referer')
```

```
return new Response('Hello, Next.js!', {
status: 200 ,
headers: { referer: referer },
})
}
```

You can also use the underlying Web APIs to read headers from the request (NextRequest):

```
app/api/route.ts (ts)
import { type NextRequest } from 'next/server'
```

```
export async function GET(request: NextRequest) {
const requestHeaders = new Headers(request.headers)
}
```

```
app/api/route.js (js)
export async function GET(request) {
const requestHeaders = new Headers(request.headers)
}
```

**Redirects**

```
app/api/route.ts (ts)
import { redirect } from 'next/navigation'
```

```
export async function GET(request: Request) {
redirect('https://nextjs.org/')
}
```

```
app/api/route.js (js)
import { redirect } from 'next/navigation'
```

```
export async function GET(request) {
redirect('https://nextjs.org/')
}
```

**Dynamic Route Segments**

```
We recommend reading the Defining Routes page before continuing.
```

Route Handlers can use Dynamic Segments to create request handlers from dynamic data.

```
app/items/[slug]/route.ts (ts)
export async function GET(
request: Request,
{ params }: { params: { slug: string } }
) {
const slug = params.slug // 'a', 'b', or 'c'
}
```

```
app/items/[slug]/route.js (js)
```

```
export async function GET(request, { params }) {
const slug = params.slug // 'a', 'b', or 'c'
}
```

```
Route Example URL paramsparams
```

```
app/items/[slug]/route.js /items/a { slug: 'a' }
```

```
app/items/[slug]/route.js /items/b { slug: 'b' }
```

```
app/items/[slug]/route.js /items/c { slug: 'c' }
```

**URL Query Parameters**

The request object passed to the Route Handler is a NextRequest instance, which has some additional convenience methods,

including for more easily handling query parameters.

```
app/api/search/route.ts (ts)
import { type NextRequest } from 'next/server'
```

```
export function GET(request: NextRequest) {
const searchParams = request.nextUrl.searchParams
const query = searchParams.get('query')
// query is "hello" for /api/search?query=hello
}
```

```
app/api/search/route.js (js)
export function GET(request) {
const searchParams = request.nextUrl.searchParams
const query = searchParams.get('query')
// query is "hello" for /api/search?query=hello
}
```

**Streaming**

Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more

about the AI SDK.

```
app/api/chat/route.ts (ts)
import OpenAI from 'openai'
import { OpenAIStream, StreamingTextResponse } from 'ai'
```

```
const openai = new OpenAI({
apiKey: process.env.OPENAI_API_KEY,
})
```

```
export const runtime = 'edge'
```

```
export async function POST(req: Request) {
const { messages } = await req.json()
const response = await openai.chat.completions.create({
model: 'gpt-3.5-turbo',
stream: true,
messages,
})
```

```
const stream = OpenAIStream(response)
```

```
return new StreamingTextResponse(stream)
}
```

```
app/api/chat/route.js (js)
import OpenAI from 'openai'
import { OpenAIStream, StreamingTextResponse } from 'ai'
```

```
const openai = new OpenAI({
apiKey: process.env.OPENAI_API_KEY,
})
```

```
export const runtime = 'edge'
```

```
export async function POST(req) {
```

```
const { messages } = await req.json()
const response = await openai.chat.completions.create({
model: 'gpt-3.5-turbo',
stream: true,
messages,
})
```

```
const stream = OpenAIStream(response)
```

```
return new StreamingTextResponse(stream)
}
```

These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly.

```
app/api/route.ts (ts)
// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
function iteratorToStream(iterator: any) {
return new ReadableStream({
async pull(controller) {
const { value, done } = await iterator.next()
```

```
if (done) {
controller.close()
} else {
controller.enqueue(value)
}
},
})
}
```

```
function sleep(time: number) {
return new Promise((resolve) => {
setTimeout(resolve, time)
})
}
```

```
const encoder = new TextEncoder()
```

```
async function* makeIterator() {
yield encoder.encode('<p>One</p>')
await sleep( 200 )
yield encoder.encode('<p>Two</p>')
await sleep( 200 )
yield encoder.encode('<p>Three</p>')
}
```

```
export async function GET() {
const iterator = makeIterator()
const stream = iteratorToStream(iterator)
```

```
return new Response(stream)
}
```

```
app/api/route.js (js)
// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream
function iteratorToStream(iterator) {
return new ReadableStream({
async pull(controller) {
const { value, done } = await iterator.next()
```

```
if (done) {
controller.close()
} else {
controller.enqueue(value)
}
},
})
}
```

```
function sleep(time) {
return new Promise((resolve) => {
setTimeout(resolve, time)
})
}
```

```
const encoder = new TextEncoder()
```

```
async function* makeIterator() {
yield encoder.encode('<p>One</p>')
await sleep( 200 )
yield encoder.encode('<p>Two</p>')
await sleep( 200 )
yield encoder.encode('<p>Three</p>')
}
```

```
export async function GET() {
const iterator = makeIterator()
const stream = iteratorToStream(iterator)
```

```
return new Response(stream)
}
```

**Request Body**

You can read the Request body using the standard Web API methods:

```
app/items/route.ts (ts)
export async function POST(request: Request) {
const res = await request.json()
return Response.json({ res })
}
```

```
app/items/route.js (js)
export async function POST(request) {
const res = await request.json()
return Response.json({ res })
}
```

**Request Body FormData**

You can read the FormData using the request.formData() function:

```
app/items/route.ts (ts)
export async function POST(request: Request) {
const formData = await request.formData()
const name = formData.get('name')
const email = formData.get('email')
return Response.json({ name, email })
}
```

```
app/items/route.js (js)
export async function POST(request) {
const formData = await request.formData()
const name = formData.get('name')
const email = formData.get('email')
return Response.json({ name, email })
}
```

Since formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you

prefer (e.g. number).

**CORS**

You can set CORS headers on a Response using the standard Web API methods:

```
app/api/route.ts (ts)
export const dynamic = 'force-dynamic' // defaults to auto
```

```
export async function GET(request: Request) {
return new Response('Hello, Next.js!', {
status: 200 ,
headers: {
'Access-Control-Allow-Origin': '*',
'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
'Access-Control-Allow-Headers': 'Content-Type, Authorization',
},
})
}
```

```
app/api/route.js (js)
export const dynamic = 'force-dynamic' // defaults to auto
```

```
export async function GET(request) {
return new Response('Hello, Next.js!', {
status: 200 ,
headers: {
'Access-Control-Allow-Origin': '*',
'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
'Access-Control-Allow-Headers': 'Content-Type, Authorization',
},
})
}
```

**Edge and Node.js Runtimes**

Route Handlers have an isomorphic Web API to support both Edge and Node.js runtimes seamlessly, including support for streaming.

Since Route Handlers use the same route segment configuration as Pages and Layouts, they support long-awaited features like general-

purpose statically regenerated Route Handlers.

You can use the runtime segment config option to specify the runtime:

```
export const runtime = 'edge' // 'nodejs' is the default
```

**Non-UI Responses**

You can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all

have built-in support.

```
app/rss.xml/route.ts (ts)
export const dynamic = 'force-dynamic' // defaults to auto
```

```
export async function GET() {
return new Response(`<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
```

```
<channel>
<title>Next.js Documentation</title>
<link>https://nextjs.org/docs</link>
<description>The React Framework for the Web</description>
</channel>
```

```
</rss>`)
}
```

```
app/rss.xml/route.js (js)
export const dynamic = 'force-dynamic' // defaults to auto
```

```
export async function GET() {
return new Response(`<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
```

```
<channel>
<title>Next.js Documentation</title>
<link>https://nextjs.org/docs</link>
<description>The React Framework for the Web</description>
</channel>
```

```
</rss>`)
}
```

**Segment Config Options**

Route Handlers use the same route segment configuration as pages and layouts.

```
app/items/route.ts (ts)
export const dynamic = 'auto'
export const dynamicParams = true
export const revalidate = false
export const fetchCache = 'auto'
export const runtime = 'nodejs'
export const preferredRegion = 'auto'
```

```
app/items/route.js (js)
```

```
export const dynamic = 'auto'
export const dynamicParams = true
export const revalidate = false
export const fetchCache = 'auto'
export const runtime = 'nodejs'
export const preferredRegion = 'auto'
```

See the API reference for more details.

### 1.1.1.11 - Middleware

Documentation path: /02-app/01-building-your-application/01-routing/11-middleware

**Description:** Learn how to use Middleware to run code before a request is completed.

{/ _The content of this doc is shared between the app and pages router. You can use the_ <PagesOnly>Content</PagesOnly> _component_

_to add content that is specific to the Pages Router. Any shared content should not be wrapped in a component._ /}

Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response

by rewriting, redirecting, modifying the request or response headers, or responding directly.

Middleware runs before cached content and routes are matched. See Matching Paths for more details.

##### Convention

Use the file middleware.ts (or .js) in the root of your project to define Middleware. For example, at the same level as pages or app,

or inside src if applicable.

##### Example

```
middleware.ts (ts)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
```

```
// This function can be marked `async` if using `await` inside
export function middleware(request: NextRequest) {
return NextResponse.redirect(new URL('/home', request.url))
}
```

```
// See "Matching Paths" below to learn more
export const config = {
matcher: '/about/:path*',
}
```

```
middleware.js (js)
import { NextResponse } from 'next/server'
```

```
// This function can be marked `async` if using `await` inside
export function middleware(request) {
return NextResponse.redirect(new URL('/home', request.url))
}
```

```
// See "Matching Paths" below to learn more
export const config = {
matcher: '/about/:path*',
}
```

##### Matching Paths

Middleware will be invoked for **every route in your project**. The following is the execution order:

```
1. headers from next.config.js
2. redirects from next.config.js
3. Middleware (rewrites, redirects, etc.)
4. beforeFiles (rewrites) from next.config.js
5. Filesystem routes (public/, _next/static/, pages/, app/, etc.)
6. afterFiles (rewrites) from next.config.js
7. Dynamic Routes (/blog/[slug])
8. fallback (rewrites) from next.config.js
```

There are two ways to define which paths Middleware will run on:

```
1. Custom matcher config
2. Conditional statements
```

**Matcher**

matcher allows you to filter Middleware to run on specific paths.

```
middleware.js (js)
export const config = {
matcher: '/about/:path*',
}
```

You can match a single path or multiple paths with an array syntax:

```
middleware.js (js)
export const config = {
matcher: ['/about/:path*', '/dashboard/:path*'],
}
```

The matcher config allows full regex so matching like negative lookaheads or character matching is supported. An example of a

negative lookahead to match all except specific paths can be seen here:

```
middleware.js (js)
export const config = {
matcher: [
/*
* Match all request paths except for the ones starting with:
* - api (API routes)
* - _next/static (static files)
* - _next/image (image optimization files)
* - favicon.ico (favicon file)
*/
'/((?!api|_next/static|_next/image|favicon.ico).*)',
],
}
```

You can also ignore prefetches (from next/link) that don’t need to go through the Middleware using the missing array:

```
middleware.js (js)
export const config = {
matcher: [
/*
* Match all request paths except for the ones starting with:
* - api (API routes)
* - _next/static (static files)
* - _next/image (image optimization files)
* - favicon.ico (favicon file)
*/
{
source: '/((?!api|_next/static|_next/image|favicon.ico).*)',
missing: [
{ type: 'header', key: 'next-router-prefetch' },
{ type: 'header', key: 'purpose', value: 'prefetch' },
],
},
],
}
```

```
Good to know : The matcher values need to be constants so they can be statically analyzed at build-time. Dynamic values such
as variables will be ignored.
```

Configured matchers:

```
1. MUST start with /
2. Can include named parameters: /about/:path matches /about/a and /about/b but not /about/a/c
3. Can have modifiers on named parameters (starting with :): /about/:path* matches /about/a/b/c because * is zero or more.? is
zero or one and + one or more
4. Can use regular expression enclosed in parenthesis: /about/(.*) is the same as /about/:path*
```

Read more details on path-to-regexp documentation.

```
Good to know : For backward compatibility, Next.js always considers /public as /public/index. Therefore, a matcher of
/public/:path will match.
```

**Conditional Statements**

```
middleware.ts (ts)
```

```
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
```

```
export function middleware(request: NextRequest) {
if (request.nextUrl.pathname.startsWith('/about')) {
return NextResponse.rewrite(new URL('/about-2', request.url))
}
```

```
if (request.nextUrl.pathname.startsWith('/dashboard')) {
return NextResponse.rewrite(new URL('/dashboard/user', request.url))
}
}
```

```
middleware.js (js)
import { NextResponse } from 'next/server'
```

```
export function middleware(request) {
if (request.nextUrl.pathname.startsWith('/about')) {
return NextResponse.rewrite(new URL('/about-2', request.url))
}
```

```
if (request.nextUrl.pathname.startsWith('/dashboard')) {
return NextResponse.rewrite(new URL('/dashboard/user', request.url))
}
}
```

##### NextResponse

The NextResponse API allows you to:

```
redirect the incoming request to a different URL
rewrite the response by displaying a given URL
Set request headers for API Routes, getServerSideProps, and rewrite destinations
Set response cookies
Set response headers
```

To produce a response from Middleware, you can:

```
1. rewrite to a route (Page or Route Handler) that produces a response
2. return a NextResponse directly. See Producing a Response
```

To produce a response from Middleware, you can:

```
1. rewrite to a route (Page or Edge API Route) that produces a response
2. return a NextResponse directly. See Producing a Response
```

##### Using Cookies

Cookies are regular headers. On a Request, they are stored in the Cookie header. On a Response they are in the Set-Cookie header.

Next.js provides a convenient way to access and manipulate these cookies through the cookies extension on NextRequest and

NextResponse.

```
1. For incoming requests, cookies comes with the following methods: get, getAll, set, and delete cookies. You can check for the
existence of a cookie with has or remove all cookies with clear.
2. For outgoing responses, cookies have the following methods get, getAll, set, and delete.
```

```
middleware.ts (ts)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
```

```
export function middleware(request: NextRequest) {
// Assume a "Cookie:nextjs=fast" header to be present on the incoming request
// Getting cookies from the request using the `RequestCookies` API
let cookie = request.cookies.get('nextjs')
console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
const allCookies = request.cookies.getAll()
console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]
```

```
request.cookies.has('nextjs') // => true
```

```
request.cookies.delete('nextjs')
request.cookies.has('nextjs') // => false
```

```
// Setting cookies on the response using the `ResponseCookies` API
const response = NextResponse.next()
response.cookies.set('vercel', 'fast')
response.cookies.set({
name: 'vercel',
value: 'fast',
path: '/',
})
cookie = response.cookies.get('vercel')
console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
// The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.
```

```
return response
}
```

```
middleware.js (js)
import { NextResponse } from 'next/server'
```

```
export function middleware(request) {
// Assume a "Cookie:nextjs=fast" header to be present on the incoming request
// Getting cookies from the request using the `RequestCookies` API
let cookie = request.cookies.get('nextjs')
console.log(cookie) // => { name: 'nextjs', value: 'fast', Path: '/' }
const allCookies = request.cookies.getAll()
console.log(allCookies) // => [{ name: 'nextjs', value: 'fast' }]
```

```
request.cookies.has('nextjs') // => true
request.cookies.delete('nextjs')
request.cookies.has('nextjs') // => false
```

```
// Setting cookies on the response using the `ResponseCookies` API
const response = NextResponse.next()
response.cookies.set('vercel', 'fast')
response.cookies.set({
name: 'vercel',
value: 'fast',
path: '/',
})
cookie = response.cookies.get('vercel')
console.log(cookie) // => { name: 'vercel', value: 'fast', Path: '/' }
// The outgoing response will have a `Set-Cookie:vercel=fast;path=/test` header.
```

```
return response
}
```

##### Setting Headers

You can set request and response headers using the NextResponse API (setting _request_ headers is available since Next.js v13.0.0).

```
middleware.ts (ts)
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
```

```
export function middleware(request: NextRequest) {
// Clone the request headers and set a new header `x-hello-from-middleware1`
const requestHeaders = new Headers(request.headers)
requestHeaders.set('x-hello-from-middleware1', 'hello')
```

```
// You can also set request headers in NextResponse.rewrite
const response = NextResponse.next({
request: {
// New request headers
headers: requestHeaders,
},
})
```

```
// Set a new response header `x-hello-from-middleware2`
response.headers.set('x-hello-from-middleware2', 'hello')
return response
}
```

```
middleware.js (js)
import { NextResponse } from 'next/server'
```

```
export function middleware(request) {
// Clone the request headers and set a new header `x-hello-from-middleware1`
const requestHeaders = new Headers(request.headers)
requestHeaders.set('x-hello-from-middleware1', 'hello')
```

```
// You can also set request headers in NextResponse.rewrite
const response = NextResponse.next({
request: {
// New request headers
headers: requestHeaders,
},
})
```

```
// Set a new response header `x-hello-from-middleware2`
response.headers.set('x-hello-from-middleware2', 'hello')
return response
}
```

```
Good to know : Avoid setting large headers as it might cause 431 Request Header Fields Too Large error depending on your
backend web server configuration.
```

##### Producing a Response

You can respond from Middleware directly by returning a Response or NextResponse instance. (This is available since Next.js v13.1.0)

```
middleware.ts (ts)
import { NextRequest } from 'next/server'
import { isAuthenticated } from '@lib/auth'
```

```
// Limit the middleware to paths starting with `/api/`
export const config = {
matcher: '/api/:function*',
}
```

```
export function middleware(request: NextRequest) {
// Call our authentication function to check the request
if (!isAuthenticated(request)) {
// Respond with JSON indicating an error message
return Response.json(
{ success: false, message: 'authentication failed' },
{ status: 401 }
)
}
}
```

```
middleware.js (js)
import { isAuthenticated } from '@lib/auth'
```

```
// Limit the middleware to paths starting with `/api/`
export const config = {
matcher: '/api/:function*',
}
```

```
export function middleware(request) {
// Call our authentication function to check the request
if (!isAuthenticated(request)) {
// Respond with JSON indicating an error message
return Response.json(
{ success: false, message: 'authentication failed' },
{ status: 401 }
)
}
}
```

###### waitUntilwaitUntil and NextFetchEventNextFetchEvent

The NextFetchEvent object extends the native FetchEvent object, and includes the waitUntil() method.

The waitUntil() method takes a promise as an argument, and extends the lifetime of the Middleware until the promise settles. This is

useful for performing work in the background.

```
middleware.ts (ts)
import { NextResponse } from 'next/server'
import type { NextFetchEvent, NextRequest } from 'next/server'
```

```
export function middleware(req: NextRequest, event: NextFetchEvent) {
event.waitUntil(
fetch('https://my-analytics-platform.com', {
method: 'POST',
body: JSON.stringify({ pathname: req.nextUrl.pathname }),
})
)
```

```
return NextResponse.next()
}
```

##### Advanced Middleware Flags

In v13.1 of Next.js two additional flags were introduced for middleware, skipMiddlewareUrlNormalize and

skipTrailingSlashRedirect to handle advanced use cases.

skipTrailingSlashRedirect disables Next.js redirects for adding or removing trailing slashes. This allows custom handling inside

middleware to maintain the trailing slash for some paths but not others, which can make incremental migrations easier.

```
next.config.js (js)
module.exports = {
skipTrailingSlashRedirect: true,
}
```

```
middleware.js (js)
const legacyPrefixes = ['/docs', '/blog']
```

```
export default async function middleware(req) {
const { pathname } = req.nextUrl
```

```
if (legacyPrefixes.some((prefix) => pathname.startsWith(prefix))) {
return NextResponse.next()
}
```

```
// apply trailing slash handling
if (
!pathname.endsWith('/') &&
!pathname.match(/((?!\.well-known(?:\/.*)?)(?:[^/]+\/)*[^/]+\.\w+)/)
) {
req.nextUrl.pathname += '/'
return NextResponse.redirect(req.nextUrl)
}
}
```

skipMiddlewareUrlNormalize allows disabling the URL normalizing Next.js does to make handling direct visits and client-transitions

the same. There are some advanced cases where you need full control using the original URL which this unlocks.

```
next.config.js (js)
module.exports = {
skipMiddlewareUrlNormalize: true,
}
```

```
middleware.js (js)
export default async function middleware(req) {
const { pathname } = req.nextUrl
```

```
// GET /_next/data/build-id/hello.json
```

```
console.log(pathname)
// with the flag this now /_next/data/build-id/hello.json
// without the flag this would be normalized to /hello
}
```

##### Runtime

Middleware currently only supports the Edge runtime. The Node.js runtime can not be used.

##### Version History

```
Version Changes
```

```
v13.1.0 Advanced Middleware flags added
```

```
v13.0.0 Middleware can modify request headers, response headers, and send responses
```

```
v12.2.0 Middleware is stable, please see the upgrade guide
```

```
v12.0.9 Enforce absolute URLs in Edge Runtime (PR)
```

```
v12.0.0 Middleware (Beta) added
```

### 1.1.1.12 - Project Organization and File Colocation

Documentation path: /02-app/01-building-your-application/01-routing/12-colocation

**Description:** Learn how to organize your Next.js project and colocate files.

```
Related:
Title: Related
Related Description: No related description
Links:
```

```
app/building-your-application/routing/defining-routes
app/building-your-application/routing/route-groups
app/building-your-application/configuring/src-directory
app/building-your-application/configuring/absolute-imports-and-module-aliases
```

Apart from routing folder and file conventions, Next.js is **unopinionated** about how you organize and colocate your project files.

This page shares default behavior and features you can use to organize your project.

```
Safe colocation by default
Project organization features
Project organization strategies
```

##### Safe colocation by default

In the app directory, nested folder hierarchy defines route structure.

Each folder represents a route segment that is mapped to a corresponding segment in a URL path.

However, even though route structure is defined through folders, a route is **not publicly accessible** until a page.js or route.js file

is added to a route segment.

And, even when a route is made publicly accessible, only the **content returned** by page.js or route.js is sent to the client.

This means that **project files** can be **safely colocated** inside route segments in the app directory without accidentally being routable.

```
Good to know :
```

```
This is different from the pages directory, where any file in pages is considered a route.
While you can colocate your project files in app you don’t have to. If you prefer, you can keep them outside the app
directory.
```

##### Project organization features

Next.js provides several features to help you organize your project.

**Private Folders**

Private folders can be created by prefixing a folder with an underscore: \_folderName

This indicates the folder is a private implementation detail and should not be considered by the routing system, thereby **opting the**

**folder and all its subfolders** out of routing.

Since files in the app directory can be safely colocated by default, private folders are not required for colocation. However, they can be

useful for:

```
Separating UI logic from routing logic.
Consistently organizing internal files across a project and the Next.js ecosystem.
Sorting and grouping files in code editors.
Avoiding potential naming conflicts with future Next.js file conventions.
```

```
Good to know
```

```
While not a framework convention, you might also consider marking files outside private folders as “private” using the same
underscore pattern.
You can create URL segments that start with an underscore by prefixing the folder name with %5F (the URL-encoded form of
an underscore): %5FfolderName.
If you don’t use private folders, it would be helpful to know Next.js special file conventions to prevent unexpected naming
conflicts.
```

**Route Groups**

Route groups can be created by wrapping a folder in parenthesis: (folderName)

This indicates the folder is for organizational purposes and should **not be included** in the route’s URL path.

Route groups are useful for:

```
Organizing routes into groups e.g. by site section, intent, or team.
Enabling nested layouts in the same route segment level:
Creating multiple nested layouts in the same segment, including multiple root layouts
Adding a layout to a subset of routes in a common segment
```

###### srcsrc Directory

Next.js supports storing application code (including app) inside an optional src directory. This separates application code from project

configuration files which mostly live in the root of a project.

**Module Path Aliases**

Next.js supports Module Path Aliases which make it easier to read and maintain imports across deeply nested project files.

```
app/dashboard/settings/analytics/page.js (jsx)
// before
import { Button } from '../../../components/button'
```

```
// after
import { Button } from '@/components/button'
```

##### Project organization strategies

There is no “right” or “wrong” way when it comes to organizing your own files and folders in a Next.js project.

The following section lists a very high-level overview of common strategies. The simplest takeaway is to choose a strategy that works

for you and your team and be consistent across the project.

```
Good to know : In our examples below, we’re using components and lib folders as generalized placeholders, their naming has
no special framework significance and your projects might use other folders like ui, utils, hooks, styles, etc.
```

###### Store project files outside of appapp

This strategy stores all application code in shared folders in the **root of your project** and keeps the app directory purely for routing

purposes.

###### Store project files in top-level folders inside of appapp

This strategy stores all application code in shared folders in the **root of the** appapp **directory**.

**Split project files by feature or route**

This strategy stores globally shared application code in the root app directory and **splits** more specific application code into the route

segments that use them.

### 1.1.1.13 - Internationalization

Documentation path: /02-app/01-building-your-application/01-routing/13-internationalization

**Description:** Add support for multiple languages with internationalized routing and localized content.

Next.js enables you to configure the routing and rendering of content to support multiple languages. Making your site adaptive to

different locales includes translated content (localization) and internationalized routes.

##### Terminology

```
Locale: An identifier for a set of language and formatting preferences. This usually includes the preferred language of the user and
possibly their geographic region.
en-US: English as spoken in the United States
nl-NL: Dutch as spoken in the Netherlands
nl: Dutch, no specific region
```

##### Routing Overview

It’s recommended to use the user’s language preferences in the browser to select which locale to use. Changing your preferred

language will modify the incoming Accept-Language header to your application.

For example, using the following libraries, you can look at an incoming Request to determine which locale to select, based on the

Headers, locales you plan to support, and the default locale.

```
middleware.js (js)
import { match } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'
```

```
let headers = { 'accept-language': 'en-US,en;q=0.5' }
let languages = new Negotiator({ headers }).languages()
let locales = ['en-US', 'nl-NL', 'nl']
let defaultLocale = 'en-US'
```

```
match(languages, locales, defaultLocale) // -> 'en-US'
```

Routing can be internationalized by either the sub-path (/fr/products) or domain (my-site.fr/products). With this information,

you can now redirect the user based on the locale inside Middleware.

```
middleware.js (js)
let locales = ['en-US', 'nl-NL', 'nl']
```

```
// Get the preferred locale, similar to the above or using a library
function getLocale(request) { ... }
```

```
export function middleware(request) {
// Check if there is any supported locale in the pathname
const { pathname } = request.nextUrl
const pathnameHasLocale = locales.some(
(locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
)
```

```
if (pathnameHasLocale) return
```

```
// Redirect if there is no locale
const locale = getLocale(request)
request.nextUrl.pathname = `/${locale}${pathname}`
// e.g. incoming request is /products
// The new URL is now /en-US/products
return Response.redirect(request.nextUrl)
}
```

```
export const config = {
matcher: [
// Skip all internal paths (_next)
'/((?!_next).*)',
// Optional: only run on root (/) URL
// '/'
],
}
```

Finally, ensure all special files inside app/ are nested under app/[lang]. This enables the Next.js router to dynamically handle

different locales in the route, and forward the lang parameter to every layout and page. For example:

```
app/[lang]/page.js (jsx)
// You now have access to the current locale
// e.g. /en-US/products -> `lang` is "en-US"
export default async function Page({ params: { lang } }) {
return ...
}
```

The root layout can also be nested in the new folder (e.g. app/[lang]/layout.js).

##### Localization

Changing displayed content based on the user’s preferred locale, or localization, is not something specific to Next.js. The patterns

described below would work the same with any web application.

Let’s assume we want to support both English and Dutch content inside our application. We might maintain two different “dictionaries”,

which are objects that give us a mapping from some key to a localized string. For example:

```
dictionaries/en.json (json)
{
"products": {
"cart": "Add to Cart"
}
}
```

```
dictionaries/nl.json (json)
{
"products": {
"cart": "Toevoegen aan Winkelwagen"
}
}
```

We can then create a getDictionary function to load the translations for the requested locale:

```
app/[lang]/dictionaries.js (jsx)
import 'server-only'
```

```
const dictionaries = {
en: () => import('./dictionaries/en.json').then((module) => module.default),
nl: () => import('./dictionaries/nl.json').then((module) => module.default),
}
```

```
export const getDictionary = async (locale) => dictionaries[locale]()
```

Given the currently selected language, we can fetch the dictionary inside of a layout or page.

```
app/[lang]/page.js (jsx)
import { getDictionary } from './dictionaries'
```

```
export default async function Page({ params: { lang } }) {
const dict = await getDictionary(lang) // en
return <button>{dict.products.cart}</button> // Add to Cart
}
```

Because all layouts and pages in the app/ directory default to Server Components, we do not need to worry about the size of the

translation files affecting our client-side JavaScript bundle size. This code will **only run on the server** , and only the resulting HTML will

be sent to the browser.

##### Static Generation

To generate static routes for a given set of locales, we can use generateStaticParams with any page or layout. This can be global, for

example, in the root layout:

```
app/[lang]/layout.js (jsx)
export async function generateStaticParams() {
return [{ lang: 'en-US' }, { lang: 'de' }]
}
```

```
export default function Root({ children, params }) {
return (
```

```
<html lang={params.lang}>
<body>{children}</body>
</html>
)
}
```

##### Resources

```
Minimal i18n routing and translations
next-intl
next-international
next-i18n-router
```

---

## Next chapter ➡️ [1.1.2 - Data Fetching](/src/docs/app-router/1.1.2.md#112---data-fetching)
